ATOMPatcher = {
	ScriptData = {
		['AdvancedDoor'] = "Scripts/Entities/Doors/AdvancedDoor.lua",
		['AIAlertness'] = "Scripts/Entities/AI/AIAlertness.lua",
		['AIAnchor'] = "Scripts/Entities/AI/AIAnchor.lua",
		['AICheckInBox'] = "Scripts/Entities/Triggers/AICheckInBox.lua",
		['AIReinforcementSpot'] = "Scripts/Entities/AI/AIReinforcementSpot.lua",
		['AISpawner'] = "Scripts/Entities/AI/AISpawner.lua",
		['AlienEnergyPoint'] = "Scripts/Entities/Multiplayer/AlienEnergyPoint.lua",
		['AlienPlayer'] = "Scripts/Entities/Actor/AlienPlayer.lua",
		['Player'] = "Scripts/Entities/Actor/Player.lua",
		['AmbientVolume'] = "Scripts/Entities/Sound/AmbientVolume.lua",
		['AnimDoor'] = "Scripts/Entities/Doors/AnimDoor.lua",
		['AnimObject'] = "Scripts/Entities/Physics/AnimObject.lua",
		['AreaBezierVolume'] = "Scripts/Entities/Physics/AreaBezierVolume.lua",
		['AreaTrigger'] = "Scripts/Entities/Triggers/AreaTrigger.lua",
		['BasicEntity'] = "Scripts/Entities/Physics/BasicEntity.lua",
		['Birds'] = "Scripts/Entities/Boids/Birds.lua",
		['Boid'] = "Scripts/Entities/Boids/Boid.lua",
		['BreakableObject'] = "Scripts/Entities/Physics/BreakableObject.lua",
		['Bugs'] = "Scripts/Entities/Boids/Bugs.lua",
		['BuyZone'] = "Scripts/Entities/Multiplayer/BuyZone.lua",
		['CameraShake'] = "Scripts/Entities/Others/CameraShake.lua",
		['CameraSource'] = "Scripts/Entities/Others/CameraSource.lua",
		['CameraTarget'] = "Scripts/Entities/Others/CameraTarget.lua",
		['CharacterAttachHelper'] = "Scripts/Entities/Others/CharacterAttachHelper.lua",
		['Chickens'] = "Scripts/Entities/Boids/Chickens.lua",
		['CinematicTrigger'] = "Scripts/Entities/Triggers/CinematicTrigger.lua",
		['CloneFactory'] = "Scripts/Entities/Others/CloneFactory.lua",
		['Cloth'] = "Scripts/Entities/Physics/Cloth.lua",
		['Cloud'] = "Scripts/Entities/Render/Cloud.lua",
		['Comment'] = "Scripts/Entities/Others/Comment.lua",
		['Constraint'] = "Scripts/Entities/Physics/Constraint.lua",
		['Crabs'] = "Scripts/Entities/Boids/Crabs.lua",
		['DeadBody'] = "Scripts/Entities/Physics/DeadBody.lua",
		['DecalPlacer'] = "Scripts/Entities/Others/DecalPlacer.lua",
		['DelayTrigger'] = "Scripts/Entities/Triggers/DelayTrigger.lua",
		['DestroyableObject'] = "Scripts/Entities/Physics/DestroyableObject.lua",
		['Dialog'] = "Scripts/Entities/Sound/Dialog.lua",
		['Door'] = "Scripts/Entities/Doors/Door.lua",
		['Elevator'] = "Scripts/Entities/Elevators/Elevator.lua",
		['ElevatorSwitch'] = "Scripts/Entities/Elevators/ElevatorSwitch.lua",
		['Explosion'] = "Scripts/Entities/Physics/Explosion.lua",
		['ExplosiveObject'] = "Scripts/Entities/Physics/ExplosiveObject.lua",
		['Factory'] = "Scripts/Entities/Multiplayer/Factory.lua",
		['Fan'] = "Scripts/Entities/Others/Fan.lua",
		['Fish'] = "Scripts/Entities/Boids/Fish.lua",
		['Flag'] = "Scripts/Entities/Multiplayer/Flag.lua",
		['Flash'] = "Scripts/Entities/Render/Flash.lua",
		['Fog'] = "Scripts/Entities/Render/Fog.lua",
		['FogVolume'] = "Scripts/Entities/Render/FogVolume.lua",
		['ForbiddenArea'] = "Scripts/Entities/Multiplayer/ForbiddenArea.lua",
		['Frogs'] = "Scripts/Entities/Boids/Frogs.lua",
		['GravityBox'] = "Scripts/Entities/Physics/GravityBox.lua",
		['GravitySphere'] = "Scripts/Entities/Physics/GravitySphere.lua",
		['GravityStream'] = "Scripts/Entities/Physics/GravityStream.lua",
		['GravityStreamCap'] = "Scripts/Entities/Physics/GravityStreamCap.lua",
		['GravityValve'] = "Scripts/Entities/Physics/GravityValve.lua",
		['GUI'] = "Scripts/Entities/Others/GUI.lua",
		['Hazard'] = "Scripts/Entities/Others/Hazard.lua",
		['HQ'] = "Scripts/Entities/Multiplayer/HQ.lua",
		['IndirectLight'] = "Scripts/Entities/Lights/IndirectLight.lua",
		['InteractiveEntity'] = "Scripts/Entities/Others/InteractiveEntity.lua",
		['Ladder'] = "Scripts/Entities/Ladders/Ladder.lua",
		['Light'] = "Scripts/Entities/Lights/Light.lua",
		['Lightning'] = "Scripts/Entities/Render/Lightning.lua",
		['Mine'] = "Scripts/Entities/Others/Mine.lua",
		['MissionHint'] = "Scripts/Entities/Sound/MissionHint.lua",
		['MissionObjective'] = "Scripts/Entities/Others/MissionObjective.lua",
		['MultipleTrigger'] = "Scripts/Entities/Triggers/MultipleTrigger.lua",
		['MusicEndTheme'] = "Scripts/Entities/Sound/MusicEndTheme.lua",
		['MusicLogicTrigger'] = "Scripts/Entities/Sound/MusicLogicTrigger.lua",
		['MusicMoodSelector'] = "Scripts/Entities/Sound/MusicMoodSelector.lua",
		['MusicPlayPattern'] = "Scripts/Entities/Sound/MusicPlayPattern.lua",
		['MusicStinger'] = "Scripts/Entities/Sound/MusicStinger.lua",
		['MusicThemeSelector'] = "Scripts/Entities/Sound/MusicThemeSelector.lua",
		['Objective'] = "Scripts/Entities/Multiplayer/Objective.lua",
		['ParticleEffect'] = "Scripts/Entities/Particle/ParticleEffect.lua",
		['Perimeter'] = "Scripts/Entities/Multiplayer/Perimeter.lua",
		['PlayerModelChanger'] = "Scripts/Entities/Others/PlayerModelChanger.lua",
		['Plover'] = "Scripts/Entities/Boids/Plover.lua",
		['PrecacheCamera'] = "Scripts/Entities/Others/PrecacheCamera.lua",
		['PressurizedObject'] = "Scripts/Entities/Physics/PressurizedObject.lua",
		['ProximityTrigger'] = "Scripts/Entities/Triggers/ProximityTrigger.lua",
		['ATOMTrigger'] = "Scripts/Entities/Triggers/ATOMTrigger.lua",
		['RaisingWater'] = "Scripts/Entities/Others/RaisingWater.lua",
		['RandomSoundVolume'] = "Scripts/Entities/Sound/RandomSoundVolume.lua",
		['ReverbVolume'] = "Scripts/Entities/Sound/ReverbVolume.lua",
		['RigidBody'] = "Scripts/Entities/Others/RigidBody.lua",
		['RigidBodyEx'] = "Scripts/Entities/Physics/RigidBodyEx.lua",
		['Rope'] = "Scripts/Entities/Physics/Rope.lua",
		['ShootingTarget'] = "Scripts/Entities/Others/ShootingTarget.lua",
		['SimpleIndirectLight'] = "Scripts/Entities/Lights/SimpleIndirectLight.lua",
		['SimpleLight'] = "Scripts/Entities/Lights/SimpleLight.lua",
		['SmartObject'] = "Scripts/Entities/AI/SmartObject.lua",
		['SmartObjectCondition'] = "Scripts/Entities/AI/SmartObjectCondition.lua",
		['SoundEventSpot'] = "Scripts/Entities/Sound/SoundEventSpot.lua",
		['SoundMoodVolume'] = "Scripts/Entities/Sound/SoundMoodVolume.lua",
		['SoundSpot'] = "Scripts/Entities/Sound/SoundSpot.lua",
		['SoundSupressor'] = "Scripts/Entities/Others/SoundSupressor.lua",
		['SpawnAlien'] = "Scripts/Entities/AISpawners/SpawnAlien.lua",
		['SpawnCivilian'] = "Scripts/Entities/AISpawners/SpawnCivilian.lua",
		['SpawnCoordinator'] = "Scripts/Entities/AISpawners/SpawnCoordinator.lua",
		['SpawnGroup'] = "Scripts/Entities/Multiplayer/SpawnGroup.lua",
		['SpawnGrunt'] = "Scripts/Entities/AISpawners/SpawnGrunt.lua",
		['SpawnHunter'] = "Scripts/Entities/AISpawners/SpawnHunter.lua",
		['SpawnObserver'] = "Scripts/Entities/AISpawners/SpawnObserver.lua",
		['SpawnPoint'] = "Scripts/Entities/Others/SpawnPoint.lua",
		['SpawnScout'] = "Scripts/Entities/AISpawners/SpawnScout.lua",
		['SpawnTrooper'] = "Scripts/Entities/AISpawners/SpawnTrooper.lua",
		['SpectatorPoint'] = "Scripts/Entities/Multiplayer/SpectatorPoint.lua",
		['Switch'] = "Scripts/Entities/Others/Switch.lua",
		['TagPoint'] = "Scripts/Entities/AI/TagPoint.lua",
		['TeamRandomSoundVolume'] = "Scripts/Entities/Multiplayer/TeamRandomSoundVolume.lua",
		['TeamSoundSpot'] = "Scripts/Entities/Multiplayer/TeamSoundSpot.lua",
		['Turtles'] = "Scripts/Entities/Boids/Turtles.lua",
		['ViewDist'] = "Scripts/Entities/Render/ViewDist.lua",
		['VolumeObject'] = "Scripts/Entities/Render/VolumeObject.lua",
		['Warrior'] = "Scripts/Entities/AI/Aliens/Warrior.lua",
		['WaterKillEvent'] = "Scripts/Entities/Others/WaterKillEvent.lua",
		['Wind'] = "Scripts/Entities/Others/Wind.lua",
		['WindArea'] = "Scripts/Entities/Physics/WindArea.lua"
	};
	------------
	cfg = {};
	------------
	Server = {};
	------------
	Client = {};
	------------
	toHook = {},
	aPatchedEntities = {},
	------------
	CheckEntity = function(self, entity)
		local script = self.ScriptData[entity];
		if (not script) then
			return false;
		end;
		if (not _G[entity] or type(_G[entity]) ~= "table") then
		--	ATOM:DebugFacTeams("BEFORE ::: reloaded"..script)
			Script.ReloadScript(script);
		--	ATOM:DebugFacTeams("AFTER ::: reloaded"..script)
		end;
		if (not _G[entity]) then
			return false;
		end;
		return true;
	end;
	------------
	Add = function(self, e, f, p, m, n)

		self.toHook[e] = checkArray(self.toHook[e])
		table.insert(self.toHook[e], {
			e,
			f,
			p,
			m,
			n
		})
		self.aPatchedEntities[e] = true
		if (self.bInitialized) then
			self:InitClass(e)
		end
	end,

	------------
	InitEntity = function(self, hEntity)

		if (not hEntity or hEntity.bInitialized or not self.aPatchedEntities[hEntity.class]) then
			return
		end

		hEntity.bInitialized = true
		self:PostInitEntity(hEntity)
	end,

	------------
	PostInitEntity = function(self, hEntity)
		self:InitClass(hEntity.class, hEntity)
	end,

	------------
	InitClass = function(self, sClass, hEntity)

		-----------
		local aClassHooks = self.toHook[sClass]
		if (not aClassHooks) then
			return ATOMLog:LogError("Attempt to initialize a non-hooked entity %s", sClass)
		end

		-----------
		if (not self:CheckEntity(sClass)) then
			return ATOMLog:LogError("Attempt to patch function of non-existent entity %s", sClass)
		end

		-----------
		if (type(_G[sClass]) ~= "table") then
			return ATOMLog:LogError("Attempt to patch a non entity %s (%s)", sClass, type(_G[sClass]))
		end

		-----------
		--SysLog(string.bool((hEntity ~= nil), "Initializing Entity %s", "Initializing all entities of Class %s"), sClass)
		local aEntities = checkArray(System.GetEntitiesByClass(sClass))
		local sEnt, fFunc, sFunc, sIndex
		for i, aHook in pairs(aClassHooks) do
			sEnt, fFunc, sFunc, sIndex =
				aHook[1],
				aHook[2],
				aHook[3],
				aHook[4]

			if (hEntity == nil) then
				if (sIndex) then
					_G[sEnt][sIndex][sFunc] = fFunc
					for ii, hPatch in pairs(aEntities) do
						hPatch[sIndex][sFunc] = fFunc
					end
				else
					_G[sEnt][sFunc] = fFunc
					for ii, hPatch in pairs(aEntities) do
						hPatch[sFunc] = fFunc
					end
				end
			else
				if (sIndex) then
					hEntity[sIndex][sFunc] = fFunc
				else
					hEntity[sFunc] = fFunc
				end
			end
		end
	end,

	------------
	Init = function(self, hInitThis)

		-----------
		local aCfg = ATOM.cfg.Immersion
		if (aCfg.AllowCaptureEverything) then
			for i, v in pairs(System.GetEntitiesByClass("Factory")or{}) do
				if ((v.Properties.szName == "air" or v.Properties.szName == "war" or v.Properties.szName == "small") and not v.capturable) then
					v.capturable = true
				end
			end
		end

		-----------
		local bSeeCloaked =  aCfg.TurretsSeeCloaked
		for i, v in pairs(System.GetEntitiesByClass("AutoTurret") or {}) do
			v.Properties.GunTurret.bFindCloaked = bSeeCloaked
		end

		-----------
		for i, aHooks in pairs(self.toHook) do
			self:InitClass(i)
		end

		-----------
		self.bInitialized = true
		ATOMLog:Log("Hooked " .. arrSize(self.toHook) .. " Entity Script-functions")
	end
};



ATOMPatcher:Add("ATOMTrigger", function(self, entity, areaId)

	--SysLog("$4[ATOM-Trigger] (Patched) OnEnterArea %s (%i)", entity:GetName(), areaId)

	for i, aEntity in pairs(self.entities) do
		aEntity[2](aEntity[1], self, entity, areaId)
	end

	self.inside[entity.id] = entity
	
end, "OnEnterArea");

ATOMPatcher:Add("ATOMTrigger", function(self, entity, areaId)

	--SysLog("$4[ATOM-Trigger] (Patched) OnLeaveArea %s (%i)", entity:GetName(), areaId)
	for i, aEntity in pairs(self.entities) do
		aEntity[3](aEntity[1], self, entity, areaId)
	end

	self.inside[entity.id] = nil

end, "OnLeaveArea");

ATOMPatcher:Add("Player", function(self)

	self.thrusterAISoundRadius = 38
	if (AI) then
		AI.RegisterWithAI(self.id, AIOBJECT_PLAYER, self.Properties,self.PropertiesInstance)
	end
	self:OnInit()


end, "OnInit", "Server")

ATOMPatcher:Add("Player", function(self)

	self:SetAIName(self:GetName())
	self:OnReset(true)

	if (ATOMPlayerUtils and not self.actor:IsPlayer() and self.actor:GetChannel() == 0) then
		Script.SetTimer(1, function()
			ATOMPlayerUtils.InitPlayer(self, -1, true)
			Debug("Bot init ....",self.actor:GetChannel())
		end)
	end

end, "OnInit")

ATOMPatcher:Add("Player", function(self, slot, pos, dir, strength, scale, ...)

	if (self.LastClientImpulse and _time - self.LastClientImpulse < 0.1) then
		return end

	self.LastClientImpulse = _time;

	if (self.isPlayer) then
		ExecuteOnAll(formatString([[
			local p=GP(%d)if (p) then p:AddImpulse(%d, %s, %s, %0.3f, %f)end
		]], self.actor:GetChannel(), slot, arr2str_(pos), arr2str_(dir), strength, scale))
	else
		ExecuteOnAll(formatString([[
			local p=GetEnt('%s')if (p) then p:AddImpulse(%d, %s, %s, %0.3f, %f)end
		]], self:GetName(), slot, arr2str_(pos), arr2str_(dir), strength, scale))
	end

	return self:AddImpulse(slot, pos, dir, strength, scale, ...);

end, "AddImpulse_All");


ATOMPatcher:Add("GravitySphere", function(self, player, time)

	self:PhysicalizeThis() -- enables for items and vehicles	
	--if (self.Properties.bPlayers) then	
		CryAction.CreateGameObjectForEntity(self.id);
		CryAction.BindGameObjectToNetwork(self.id);  -- enables for players
	--end
	
end, "OnInit");

ATOMPatcher:Add("GravitySphere", function(self, radius)

	radius = math.max(0.01, tonumber(radius));
	local scale = radius / self.Properties.Radius;
	
	self:PhysicalizeThis(radius);
	self:SetScale(scale);
	
end, "SetRadius");

ATOMPatcher:Add("GravitySphere", function(self, gravity)

	if (gravity) then
		self.Properties.Gravity = gravity
	end
	self:PhysicalizeThis();
	
end, "SetGravity");

ATOMPatcher:Add("GravitySphere", function(self, gravity)

	
	local props = self.Properties;
	local Area = self._PhysTable.Area;
	
	Area.type = AREA_SPHERE;
	Area.radius = radius or props.Radius;
	Area.uniform = props.bUniform;
	Area.falloff = props.Falloff;
	Area.gravity = props.Gravity;
	Area.damping = props.Damping;
	
	self:Physicalize( 0,PE_AREA,self._PhysTable );
	self:SetPhysicParams(PHYSICPARAM_FOREIGNDATA,{foreignData = ZEROG_AREA_ID});  -- enables for items and vehicles
	
end, "PhysicalizeThis");

--------------------------------------------------------

ATOMPatcher:Add("ForbiddenArea", function(self, player, time)


	local bRemove = player:InGodMode() or ATOM.cfg.DisableForbiddenAreas
	if ((player.actor:GetSpectatorMode() ~= 0) or player:IsDead() or bRemove) then
	--	g_gameRules.game:ForbiddenAreaWarning(false, 0, player.id);
		if (bRemove) then
			self.warning[player.id] = nil;
			for i, v in pairs(self.inside)do
				if (v == player.id) then 
					table.remove(self.inside, v) end
			end
		end
		return
	end

	local warning = self.warning[player.id];
	if (warning and warning > 0) then
		warning = warning - (time / 1000);
		self.warning[player.id] = warning;
	elseif (not warning) then
		warning = self.delay;
		self.warning[player.id] = warning;
	end
	
	if (self.showWarning) then	
		g_gameRules.game:ForbiddenAreaWarning(true, warning, player.id);
	end;
	
	if (warning <= 0) then
		g_gameRules:CreateHit(player.id, player.id, player.id, self.dps * (time / 1000), nil, nil, nil, "punish");
	end;
	
end, "PunishPlayer");

ATOMPatcher:Add("ForbiddenArea", function(self, entity, areaId)

	--SysLog("FUCK ENTITY2");
		--	Debug("GOD MODE!!!!!!!!")
	
	if (entity.actor) then
	
		local inside = false;	
		for i, v in ipairs(self.inside) do
			if (v == entity.id) then
				inside = true break end
		end
		
		if (inside) then
			return end
		
		table.insert(self.inside, entity.id)
		
		if ((not self.teamId) or (self.teamId ~= g_gameRules.game:GetTeam(entity.id))) then
			if (not self.reverse) then
				self.warning[entity.id] = self.delay
				
				if (self.showWarning) then
					if ((entity.actor:GetSpectatorMode()==0) and (not entity:IsDead())) then
						g_gameRules.game:ForbiddenAreaWarning(true, self.delay, entity.id) end end
			else
				self.warning[entity.id] = nil
				
				if (self.showWarning) then
					g_gameRules.game:ForbiddenAreaWarning(false, 0, entity.id) end
			end
		end
	end
	
end, "OnEnterArea", "Server");

ATOMPatcher:Add("ForbiddenArea", function(self, entity, areaId)

	--SysLog("FUCK ENTITY3");
		--	Debug("G34324234OD MODE!!!!!!!!!")
	
	if (entity.actor) then--[[
		if (entity.godMode) then
			for i,v in ipairs(self.inside or{}) do
				if (v==entity.id) then
					table.remove(self.inside, i);
					break;
				end
			end	
			self.warning[entity.id]=nil;
			return;
		end;--]]
		local inside=false;
		for i,v in ipairs(self.inside) do
			if (v==entity.id) then
				inside=true;
				table.remove(self.inside, i);
				break;
			end
		end	
		
		if ((not self.teamId) or (self.teamId~=g_gameRules.game:GetTeam(entity.id))) then
			if (self.reverse) then
				if (inside) then
					self.warning[entity.id]=self.delay;
				
					if (self.showWarning) then
						if ((entity.actor:GetSpectatorMode()==0) and (not entity:IsDead())) then
							g_gameRules.game:ForbiddenAreaWarning(true, self.delay, entity.id);
						end
					end
				end
			else
				self.warning[entity.id]=nil;
				
				if (self.showWarning) then
					g_gameRules.game:ForbiddenAreaWarning(false, 0, entity.id);
				end
			end
		end
	end
	
end, "OnLeaveArea", "Server");


ATOMPatcher:Add("Door", function(self)
	return self.action == DOOR_OPEN;
end, "IsOpen");


ATOMPatcher:Add("Door", function(self, hit)
	--Debug("!")
	local weapon = hit.weapon;
	local player = hit.shooter;
	local open = 0;
	if (weapon and (weapon.class == "Fists" or weapon.class == "c4explosive")) then
		open = weapon.class == "c4explosive" and 2 or 1;
	end;
	
	if (open > 0 and player and player.isPlayer and (open == 2 or player:GetSuitMode(NANOMODE_STRENGTH)) and not self:IsOpen()) then
		--Debug("OPEN!!>>")
		local relative = self.Properties.Rotation.bRelativeToUser;
		self.Properties.Rotation.bRelativeToUser = 1;
		self.Server.SvRequestOpen(self, player.id, true, true);
		self.Properties.Rotation.bRelativeToUser = relative;
		SpawnEffect("explosions.Deck_sparks.VTOL_explosion", hit.pos, hit.normal, 0.05)
	end;
	
end, "OnHit", "Server", true);


ATOMPatcher:Add("Door", function(self, idPlayer, bOpen, bIgnoreChecks)

	local hUser = System.GetEntity(idPlayer);
	if (not hUser) then
		return false
	end
	if (not hUser.isPlayer and not hUser.isServer) then
		if (timerexpired(self.hTimerLog, 3)) then
			self.hTimerLog = timerinit()
			SysLog("Blocked suspicios Door Interaction by entity '%s'", hUser:GetName())
		end
		return false
	end
	hUser.LastInteractiveActivity = _time

	if (not bIgnoreChecks) then
		if (self.LastUsedTime) then
			if (_time - self.LastUsedTime < 0.1) then
				return false
			end
		end
		self.LastUsedTime = _time;

		if (not ATOMDefense:OpenDoor(hUser, self)) then
			return false
		end

		if (not ATOMBroadcastEvent("CanOpenDoor", self, hUser)) then
			return false
		end
	end

	local bMode = DOOR_TOGGGLE
	if (bOpen) then
		bMode = DOOR_OPEN
	else
		bMode = DOOR_CLOSE
	end

	if (g_utils.LOCK_DOWN and not hUser.megaGod) then
		if (hUser.isPlayer) then
			SendMsg(ERROR, hUser, "You cannot leave your home during lockdown!")
		end
		return false
	end

	if (self.Locked) then
		if (hUser.isPlayer) then
			SendMsg(ERROR, hUser, (self.Locked or "Door is Locked"))
		end
		return false
	end

	if (self.bLastMode) then
		if (self.bLastMode == bMode) then
			bMode = (not bMode)
		end
	end

	self.bLastMode = bMode

	if (self.AutoClose) then
		if (self.AutoCloseTimer) then
			Script.KillTimer(self.AutoCloseTimer)
		end
		self.AutoCloseTimer = Script.SetTimer(self.AutoClose.timer * 1000, function()
			if (self:IsOpen()) then
				self:Open(ATOM.Server, DOOR_CLOSE)
			end
		end)
	end

	self:Open(hUser, bMode)
end, "SvRequestOpen", "Server", true);

---------------------------------------------------------------------------



ATOMPatcher:Add("Elevator", function(self)
				Elevator.SetPropertiesFromName(self);
				if (self.currModel ~= self.Properties.objModel) then
					CryAction.ActivateExtensionForGameObject(self.id, "ScriptControlledPhysics", false);
					self:LoadObject( 0,self.Properties.objModel );
					self:Physicalize(0,PE_RIGID,{mass=0});
					CryAction.ActivateExtensionForGameObject(self.id, "ScriptControlledPhysics", true);
				end
				self.currModel = self.Properties.objModel;
end, "DoPhysicalize");

ATOMPatcher:Add("Elevator", function(self)
				local name = self:GetName();
				local obj, dest, floorCunt, floorHeight, floorInit, accel, axis, speed, stopTime, sndMove, sndStart, sndStop, trash = name:match(
					"(.*)|(.*)+(.*)+(.*)+(.*)|(.*)+(.*)+(.*)+(.*)|(.*)+(.*)+(.*)|(.*)"
				);
				-- model
				if (obj) then
					self.Properties.objModel = obj;
				end;
				-- moving
				if (dest and tonumber(dest)) then
					self.Properties.nDestinationFloor = tonumber(dest);
				end;
				if (floorCunt and tonumber(floorCunt)) then
					self.Properties.nFloorCount = tonumber(floorCunt);
				end;
				if (floorHeight and tonumber(floorHeight)) then
					SysLog("FLOOR HEIGHT: %d",tonumber(floorHeight))
					self.Properties.fFloorHeight = tonumber(floorHeight);
				end;
				if (floorInit and tonumber(floorInit)) then
					self.Properties.nInitialFloor = tonumber(floorInit);
				end;
				-- slide
				if (accel and tonumber(accel)) then
					self.Properties.Slide.fAcceleration = tonumber(accel);
				end;
				if (axis and (axis=="x" or axis=="z" or axis=="y")) then
					self.Properties.Slide.sAxis = axis;
				end;
				if (speed and tonumber(speed)) then
					self.Properties.Slide.fSpeed = tonumber(speed);
				end;
				if (stopTime and tonumber(stopTime)) then
					self.Properties.Slide.fStopTime = tonumber(stopTime);
				end;
				-- sounds
				if (sndMove and string.len(sndMove) > 3) then
					self.Properties.Sounds.soundSoundOnMove = sndMove;
				end;
				if (sndStart and string.len(sndStart) > 3) then
					self.Properties.Sounds.soundSoundOnStart = sndStart;
				end;
				if (sndStop and string.len(sndStop) > 3) then
					self.Properties.Sounds.soundSoundOnStop = sndStop;
				end;
				
end, "SetPropertiesFromName");

ATOMPatcher:Add("ElevatorSwitch", function(self)
				ElevatorSwitch.SetPropertiesFromName(self);
				if (self.currModel ~= self.Properties.objModel) then
					self:LoadObject( 0,self.Properties.objModel );
					self:Physicalize(0,PE_RIGID, {mass=0});
				end
				
				self.currModel = self.Properties.objModel;
end,"DoPhysicalize");
ATOMPatcher:Add("ElevatorSwitch", function(self)
				local name = self:GetName();
				local obj, delay, floor, useMsg, sndUse, trash = name:match(
					"(.*)|(.*)+(.*)|(.*)|(.*)|(.*)"
				);
				-- model
				if (obj) then
					self.Properties.objModel = obj;
				end;
				-- moving
				if (delay and tonumber(delay)) then
					self.Properties.fDelay = tonumber(delay);
				end;
				if (floor and tonumber(floor)) then
					self.Properties.nFloor = tonumber(floor);
				end;
				-- use
				if (useMsg) then
					self.Properties.szUseMessage = useMsg;
				end;
				-- sound
				if (sndUse) then
					self.Properties.Sounds.soundSoundOnPress = sndUse;
				end;
				
				
end, "SetPropertiesFromName");

---------------------------------------------------------------------------
---------------------------------------------------------------------------

ATOMPatcher:Add("BasicEntity", function(self, playerId, class, props)
	self.bRigidBodyActive = 1;
	self:SetFromProperties();
	--SysLog("SPAWN!!")
end, "OnSpawn");

ATOMPatcher:Add("BasicEntity", function(self, playerId, class, props)
			

	--SysLog( "BasicEntity:SetPropertiesFromName()");

	local modelName, bHasPhys, fMass, fDistance, particleEffect, garbage = self:GetName():match("(.*)|(.*)+(.*)+(.*)|(.*)|(.*)");
				
	local t = (modelName and modelName:sub(-4) or "");
	if (modelName and (t == ".cga" or t == ".cgf" or t == ".chr" or t == ".cdf")) then 
		self.Properties.object_Model = modelName;
		SysLog( "Got model, %s", self.Properties.object_Model);
	end 
	if (fMass) then
		self.Properties.Physics.fMass = tonumber(fMass);
	end;
	if (bHasPhys) then
		self.Properties.Physics.bRigidBody = tonumber(bHasPhys);
		self.Properties.Physics.bPhysicalize = tonumber(bHasPhys);
		self.Properties.Physics.bPushableByPlayers = tonumber(bHasPhys);
	end;
	if (fDistance) then
		self.Properties.fDistance = tonumber(fDistance);
	end;
	if (particleEffect and string.len(particleEffect) > 3) then
		self.Properties.sParticleEffect = tostring(sParticleEffect);
	end;
				
	--SysLog( "BasicEntity: Name Params: %s, %s, %s, %s, %s (%s)", tostring(modelName), tostring(bHasPhys), tostring(fMass), tostring(fDistance), tostring(particleEffect), tostring(garbage));
				
end, "SetPropertiesFromName");

ATOMPatcher:Add("BasicEntity", function(self, playerId, class, props)

		BasicEntity.SetPropertiesFromName(self);
			
		local Properties = self.Properties;

		if (Properties.object_Model == "") then
			return;
		end
				
		self.freezable = tonumber(Properties.bFreezable)~=0;
				
		self:LoadObject(0, Properties.object_Model);
				
		if (Properties.object_ModelFrozen ~= "") then
			self.frozenModelSlot = self:LoadObject(-1, Properties.object_ModelFrozen);
			self:DrawSlot(self.frozenModelSlot, 0);
		else
		self.frozenModelSlot = nil;
	  end
				
		if (Properties.Physics.bPhysicalize == 1) then
			self:PhysicalizeThis();
		end

		-- Mark AI hideable flag.
		if (Properties.bAutoGenAIHidePts == 1) then
			self:SetFlags(ENTITY_FLAG_AI_HIDEABLE, 0); -- set
		else
			self:SetFlags(ENTITY_FLAG_AI_HIDEABLE, 2); -- remove
		end
end, "SetFromProperties");
---------------------------------------------------------------------------

ATOMPatcher:Add("Factory", function(self, playerId, class, props)
	if (self:CanBuild(class)) then
		return self:Queue(class, playerId, props);
	else
		self:Message(playerId, TextMessageError, "@mp_CannotBuild!");
	end
	return false;
end, "Buy", nil, true);



ATOMPatcher:Add("Factory", function(self, slot, frameTime)
	if (not slot.enabled) then
		return;
	end
	
	if (slot.building) then
		slot.buildTimer=slot.buildTimer-frameTime;

		if (slot.buildTimer<=0) then
			local vehicle=self:BuildVehicle(slot);
			self:StopBuilding(slot, true);
			
			if (g_gameRules.Server.OnVehicleBuilt) then
				g_gameRules.Server.OnVehicleBuilt(g_gameRules, self, slot.buildVehicle, vehicle.id, slot.buildOwnerId, slot.buildTeamId, slot.id);
			end

			self.allClients:ClVehicleBuilt(slot.buildVehicle, vehicle.id, slot.buildOwnerId, slot.buildTeamId, slot.id);
			slot.builtVehicleId=vehicle.id;
		end
	end

	if (slot.opening) then
		slot.openTimer=slot.openTimer-frameTime;
		if (slot.openTimer<=0) then
			
			if (not self.isClient) then
				self:OpenSlot(slot, true, false);
			end
			
			-- need to tell the clients that this is a buy zone
			if (slot.builtVehicleId) then
				local def=g_gameRules:GetItemDef(slot.buildVehicle);
				if (def.buyzoneradius and def.buyzoneflags) then
					self.allClients:ClSetBuyFlags(slot.builtVehicleId, def.buyzoneflags);
					local t = GetEnt(slot.builtVehicleId);
					if (t) then
						t.SynchedBuyZone = { self.id, def.buyzoneflags };
					end;
				end
			end
			
			self.allClients:ClOpenSlot(slot.id, true, false);
			slot.opening=false;
			slot.builtVehicleId=nil;
		end
	elseif (slot.closing) then
		self:KillPlayers(slot);
		slot.closeTimer=slot.closeTimer-frameTime;

		if (slot.closeTimer<=0) then
			if (not self.isClient) then
				self:OpenSlot(slot, false, false);
			end

			self.allClients:ClOpenSlot(slot.id, false, false);	
			slot.closing=false;
		end
	end
end, "UpdateSlot", nil, true);



ATOMPatcher:Add("Factory", function(self, vehicle)
	return self.vehicles[vehicle] or (VEHICLE_BUY_LISTS[self.id] and VEHICLE_BUY_LISTS[self.id][vehicle]);
end, "CanBuild", nil, true);

ATOMPatcher:Add("Factory", function(self, class, ownerId, props)
	local slot=self:GetFreeSlot();
	if (slot) then
		local time=self:GetBuildTime(class);
		if (not time) then
			Log("Vehicle Factory %s - Can't build that!", self:GetName());

			return false;
		end
		self:StartBuilding(slot, time, class, ownerId, g_gameRules.game:GetTeam(ownerId), props);
		
		return true;
	end
	SysLog("FATAL: NO BUY SLOT FREE!!! POTENTIAL PROPERTIES NOT ADDED!!!");
	if (self:AddToQueue(class, ownerId)) then
		return true;
	else
		Log("Vehicle Factory %s - No free factory slots available and queue is full!", self:GetName());

		return false;
	end
end, "Queue", nil, true);

ATOMPatcher:Add("Factory", function(self, slot, time, class, ownerId, teamId, props)

	local player = GetEnt(ownerId);
	if (player and (player.megaGod or player.megaShopper)) then
		time = 1;
	end;

	Log("Vehicle Factory %s - Building %s... ready in %d seconds at door %d...", self:GetName(), class, time, slot.id);

	if (g_gameRules.Server.OnVehicleBuildStart) then
		g_gameRules.Server.OnVehicleBuildStart(g_gameRules, self, class, ownerId, teamId, slot.id, time);
	end

	self.allClients:ClVehicleBuildStart(class, ownerId, teamId, slot.id, time);

	slot.vehicleProps = props;
	

	slot.building=true;
	slot.buildTimer=time;
	slot.buildVehicle=class;
	slot.buildOwnerId=ownerId;
	slot.buildTeamId=teamId;

	self.building=self.building+1;
	if (self.building==1) then
		self:SetBusy(true);
	end
	
	slot.closing=true;
	slot.closeTimer=2.0;
end, "StartBuilding", nil, true);


ATOMPatcher:Add("Factory", function(self, slot)
	local def=g_gameRules:GetItemDef(slot.buildVehicle);
	if ((not def) or (not def.vehicle)) then
		return;
	end
	local pos,dir;
	if (self:GetName() == "__AirFieldFactory") then
		 pos,dir={x=2539,y=1471,z=297},{x=0.735036,y=0.677731,z=0.0200827};
	else
		 pos,dir=self:GetParkingLocation(slot);
	end;
	if (def.modification) then
		self.spawnparams.properties.Modification=def.modification;
	else
		self.spawnparams.properties.Modification=nil;
	end
	if (def.abandon) then
		if (def.abandon>0) then
			self.spawnparams.properties.Respawn.bAbandon=1;
			self.spawnparams.properties.Respawn.nAbandonTimer=def.abandon;
		else
			self.spawnparams.properties.Respawn.bAbandon=0;
		end
	else
		self.spawnparams.properties.Respawn.bAbandon=1;
		self.spawnparams.properties.Respawn.nAbandonTimer=300;	
	end
	self.spawnparams.position=pos;
	self.spawnparams.orientation=dir;
	self.spawnparams.name=slot.buildVehicle.."_built_"..g_utils:SpawnCounter();	
	self.spawnparams.class=def.class;
	self.spawnparams.position.z=pos.z;
	if (self:GetTeamId()~=0 and g_gameRules.VehiclePaint) then
		self.spawnparams.properties.Paint = g_gameRules.VehiclePaint[g_gameRules.game:GetTeamName(self:GetTeamId())] or "";
	end
	local vehicle=System.SpawnEntity(self.spawnparams);
	local props = slot.vehicleProps or def.VehicleProperties;
	if (props) then
		if (props.Tags) then
			for tag, val in pairs(props.Tags) do
				vehicle[tag] = val;
				SysLog("added key %s for vehicle", tag)
			end;
		end;
		local modelProps = props.ModelProperties;
		if (modelProps) then
			Script.SetTimer(300, function()
				g_utils:LoadVehicleModel(vehicle, modelProps[1], modelProps[2], modelProps[3]);--, newModel[2][4], newModel[2][5]);
			end);
			SysLog("Factory:BuildVehicle() custom model properties found")
		end;
		if (props.Call) then
			local s, e = pcall(props.Call, vehicle, GetEnt(slot.buildOwnerId))
			if (not s) then
				ATOMLog:LogError(e);
			end;
		end;
		SysLog("Factory:BuildVehicle() Properties found for %s (%s)", vehicle.class,vehicle:GetName());
	end;
		
	if (vehicle) then
		Log("Vehicle Factory %s - Built %s at door %s...", self:GetName(), slot.buildVehicle, slot.id);
		vehicle.builtas=slot.buildVehicle;
		vehicle.vehicle:SetOwnerId(slot.buildOwnerId);
		g_gameRules.game:SetTeam(slot.buildTeamId, vehicle.id);
		self:AdjustVehicleLocation(vehicle);
		vehicle:AwakePhysics(1);
	end
	if (def.buyzoneradius) then
		self:MakeBuyZone(vehicle, def.buyzoneradius*1.15, def.buyzoneflags);
		if (not def.spawngroup) then
			g_gameRules.game:AddMinimapEntity(vehicle.id, 1, 0);
		end
	end
	if (def.servicezoneradius) then
		self:MakeServiceZone(vehicle, def.servicezoneradius*1.15);
	end
	if (def.spawngroup) then
		g_gameRules.game:AddSpawnGroup(vehicle.id);
	end
	ATOMBuying:OnVehicleBought(GetEnt(slot.buildOwnerId), vehicle)
	
	return vehicle;
end, "BuildVehicle", nil, true);

ATOMPatcher:Add("Factory", function(self, teamId)
	
	self:SetTeamId(teamId);
	self.captured = true;
	self.capturing = false;
	self.capturingTeamId = nil;
	self.capturingTimer = nil;
	self.lastCapturingTimer = nil;
	
	Log("%s - CAPTURED by team '%s'...", self:GetName(), g_gameRules.game:GetTeamName(teamId) or "");
	
	local players=self.inside;
	if (players) then
		local value=0;
		if (g_gameRules.captureValue) then
			local idx=self:GetCaptureIndex();
			value=g_gameRules.captureValue[idx] or 0;
		end
		
		if (g_gameRules.AwardPPCount and (value>0)) then
			for i,playerId in ipairs(players) do
				if (g_gameRules.game:GetTeam(playerId)==teamId) then
					local player=System.GetEntity(playerId);
					if (player and player.actor and (not player:IsDead()) and (player.actor:GetSpectatorMode() == 0)) then
						SendMsg(BLE_CURRENCY, player, "%s Captured ( +%d PP )", GetBuildingName(self), value)
						g_gameRules:AwardPPCount(playerId, value, nil, true);
						g_gameRules:AwardCPCount(playerId, g_gameRules.cpList.CAPTURE);
					end
				end
			end
		end
	end
		
	if (self.CaptureLinks) then
		self:CaptureLinks("capture", teamId);
		self:CaptureLinks("setteam", teamId);
	end

	if (g_gameRules.Server.OnCapture) then
		g_gameRules.Server.OnCapture(g_gameRules, self, teamId);
	end

	self.allClients:ClCapture(teamId);
end, "Capture", nil, true)

ATOMPatcher:Add("SpawnGroup", function(self, teamId)
	Factory.Capture(self, teamId)
end, "Capture", nil, true)



